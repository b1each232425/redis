package cmn

import (
	"fmt"
	"reflect"
	"regexp"
	"strings"

	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

// json data type:  object, array, string, number, boolean, and null

const columnNameRegPtn = `^\(*(?P<name>[_a-zA-Z]\w*)(((?P<obj>->)|(?P<txt>->>))(\d|'\w+'))*\)*(::\w+)?`

var columnNameRegEx = regexp.MustCompile(columnNameRegPtn)

func getColumnName(column string) (name string, jsonOpr bool) {
	match := columnNameRegEx.FindStringSubmatch(column)
	if len(match) == 0 {
		return
	}

	matchResult := make(map[string]string)
	for k, v := range columnNameRegEx.SubexpNames() {
		if k == 0 || v == "" {
			continue
		}
		matchResult[v] = match[k]
	}

	name = matchResult["name"]
	jsonObjOpr := matchResult["obj"]
	jsonTXTOpr := matchResult["txt"]

	jsonOpr = jsonObjOpr != "" || jsonTXTOpr != ""
	return
}

/*
isValidDataSets

		check req's data set is empty or not
		param s type req string, just like {"action":"update", "data":{"ID":1234,"Name":"alic"}}
		param path check target, for example, if it's value is data then the target is
				{"ID":1234,"Name":"alic"}
	  param exclude uncheck fields, for example, if exclude = ["ID"], then the data value
				{"ID":1234,"Name":""} would be get invalid/empty check result

jhd

		examples
			result param                          data
			false  (s,"data",[]string{"ID"})       {"data":{"ID":1234,"a":null,"b":"","c":null}}
	    true   (s,"data",[]string{"ID"})       {"data":{"ID":1234,"name":"valid","a":null,"b":"","c":null}}
	    false  (s,"",    []string{"ID"})         {"a":null,"b":"","c":null}
*/
func isValidDataSets(s, path string, exclude []string) (valid bool) {
	var err error
	var excludePath string
	if path != "" {
		excludePath = path + "."
	} else {
		excludePath = ""
	}
	for _, v := range exclude {
		if v == "" {
			continue
		}
		s, err = sjson.Delete(s, excludePath+v)
		if err != nil {
			fmt.Println(err.Error())
			return
		}
	}

	var r gjson.Result
	if path == "" {
		r = gjson.Parse(s)
	} else {
		r = gjson.Get(s, path)
	}

	r.ForEach(func(k, v gjson.Result) bool {
		if v.Type != gjson.Null && (v.Str != "" || v.Type == gjson.Number || v.Type == gjson.True || v.Type == gjson.False || v.Type == gjson.JSON) {
			valid = true
			return false
		}
		return true
	})
	return
}

/*
	Filter的条件表达式及参数值构造
	select
		where 表达式为expr，参数为 values

	update
		where 表达式为expr，参数为 values

	delete
		where 表达式为expr，参数为 values

Filter construct DML where clause
*/
type Filter struct {
	TableMap interface{} // struct that represent the table generated by DGW

	Action string // which type DML: insert, update, select, delete

	Condition string // DML where condition in json

	// 对于delete/update/select适用，insert不使用该值
	Expr string // DML where condition in SQL with value

	// 仅仅包含where条件中的值,对于delete/select来说与values相同
	// whereValues []interface{}

	// 包含update set column= value的中value值，及where条件中的值，对于delete/select来说与whereValues相同
	Values []interface{}

	Columns []string

	QryResult interface{} // json marshaled object array

	Result []interface{} // array of struct

	RowCount int64

	// 授权表达式
	AuthExpr string

	// 授权where表达式对应的参数值
	//authValues []interface{}

	// 授权where表达式的开始位置
	//authBeginPos int

	// 授权where表达式对应的参数值
	AuthWhereValues []interface{}

	// 授权where表达式的开始位置
	AuthWhereBeginPos int

	// 生成授权表达式, true: 生成授权表达式，false: 生成数据处理表达式
	AuthProc bool
}

type filter = Filter

var isOperandList = map[string]bool{
	"NULL":    true,
	"TRUE":    true,
	"FALSE":   true,
	"UNKNOWN": true,

	"NOT NULL":    true,
	"NOT TRUE":    true,
	"NOT UNKNOWN": true,
	"NOT FALSE":   true,
}

// a NOT BETWEEN v1 AND v2
// a BETWEEN SYMMETRIC v1 AND v2
// a NOT BETWEEN SYMMETRIC v1 AND v2
// a IS NULL
// a IS NOT NULL
// a ISNULL
// a NOTNULL
// a IS DISTINCT FROM v1
// a IS NOT DISTINCT FROM v1
var oprList = map[string]string{
	"EXPR_IS": "EXPR_IS",

	"EQ":  "=",
	"EQU": "=",
	"LT":  "<",
	"GT":  ">",
	"LTE": "<=",
	"GTE": ">=",
	"NEQ": "!=",

	"RE": "regexp_match",

	"IN": "IN",
	"IS": "IS",

	"IS_DISTINCT_FROM":     "IS DISTINCT FROM",
	"IS_NOT_DISTINCT_FROM": "IS NOT DISTINCT FROM",

	"LIKE":  "LIKE",
	"ILIKE": "ILIKE",

	"BETWEEN":     "BETWEEN",
	"NOT_BETWEEN": "NOT BETWEEN",

	"BETWEEN_SYMMETRIC":     "BETWEEN SYMMETRIC",
	"NOT_BETWEEN_SYMMETRIC": "NOT BETWEEN SYMMETRIC",

	//---------- jsonb support --------
	"@>": "@>",
	"<@": "<@",
	"?":  "?",
	"?|": "?|",
	"?&": "?&",

	"@?": "@?",
	"@@": "@@",

	//vars, silent不是操作符，仅用于格式占位
	"vars":   "vars",
	"silent": "silent",

	"jsonb_path_exists": "jsonb_path_exists",
	"jsonb_path_match":  "jsonb_path_match",

	"jsonb_path_exists_tz": "jsonb_path_exists_tz",
	"jsonb_path_match_tz":  "jsonb_path_match_tz",

	//"jsonb_path_query":  "jsonb_path_query",

	//"jsonb_path_query_array": "jsonb_path_query_array",
	//"jsonb_path_query_first": "jsonb_path_query_first",

	//"jsonb_path_query_tz":  "jsonb_path_query_tz",
	//"jsonb_path_query_array_tz": "jsonb_path_query_array_tz",
	//"jsonb_path_query_first_tz": "jsonb_path_query_first_tz",
}

func mapOpr(opr string) (dstOpr string, exists bool) {
	dstOpr, exists = oprList[opr]
	return
}

const connectPreviousBy = "connectBy"

// mapKey map json key to db on fieldName and json tag
func (r *Filter) mapKey(key string) (dbColumnName string, found bool) {
	if key == "" {
		return "", false
	}
	key = strings.ToUpper(key)

	p := reflect.ValueOf(r.TableMap)
	if p.IsNil() {
		z.Error("tableDefineStructPtr is nil")
		return "", false
	}

	t := reflect.TypeOf(p.Elem().Interface())

	if t.Kind() != reflect.Struct {
		z.Error(t.Name() + " is not struct")
		return "", false
	}

	var f reflect.StructField
	for i := 0; i < t.NumField(); i++ {
		f = t.Field(i)
		if strings.ToUpper(f.Name) == key {
			found = true
			dbColumnName = f.Name
			break
		}

		s, ok := f.Tag.Lookup("json")
		if !ok {
			continue
		}
		if s == "" {
			continue
		}
		n := strings.Split(s, ",")[0]
		if strings.ToUpper(n) == key {
			found = true
			dbColumnName = n
			break
		}
	}
	if !found {
		return
	}

	s, ok := f.Tag.Lookup("db")
	if !ok || s == "" {
		return
	}
	s = strings.Split(s, ",")[0]
	if s == "" {
		found = false
	}
	dbColumnName = s
	return
}

// -------------
func (r *Filter) CreateFilter(req *ReqProto) (expr string, err error) {
	expr, err = r.MakeFilter(req.Filter)
	if err != nil {
		return
	}
	expr = strings.TrimSpace(expr)
	expr = strings.ReplaceAll(expr, "  ", " ")
	expr = strings.ReplaceAll(expr, "( ", "(")
	expr = strings.ReplaceAll(expr, " )", ")")
	if len(expr) > 2 && expr[0] == '(' && expr[len(expr)-1] == ')' {
		expr = expr[1 : len(expr)-1]
	}
	r.Expr = expr
	// -------------
	// auth filter expression
	r.AuthProc = true
	r.AuthWhereBeginPos = len(r.Values)
	r.AuthExpr, err = r.MakeFilter(req.AuthFilter)
	if err != nil {
		return
	}
	r.AuthExpr = strings.TrimSpace(r.AuthExpr)
	r.AuthExpr = strings.ReplaceAll(r.AuthExpr, "  ", " ")
	r.AuthExpr = strings.ReplaceAll(r.AuthExpr, "( ", "(")
	r.AuthExpr = strings.ReplaceAll(r.AuthExpr, " )", ")")
	if len(r.AuthExpr) > 2 && r.AuthExpr[0] == '(' && r.AuthExpr[len(r.AuthExpr)-1] == ')' {
		r.AuthExpr = r.AuthExpr[1 : len(r.AuthExpr)-1]
	}

	//--------------
	return
}

func (r *Filter) MakeFilter(conditions interface{}) (expr string, err error) {
	exprObj := reflect.ValueOf(conditions)
	switch exprObj.Kind() {
	case reflect.Invalid:
		return
	case reflect.String:
		s, _ := conditions.(string)
		if s != "" {
			break
		}
		return
	case reflect.Map:
		s, _ := conditions.(map[string]interface{})
		if len(s) > 0 {
			break
		}
		return
	case reflect.Slice:
		if exprObj.Len() == 0 {
			return
		}
	}

	var connector string

	objType := reflect.TypeOf(conditions)
	switch objType.Kind() {
	case reflect.Slice:
		a := reflect.ValueOf(conditions)
		for i := 0; i < a.Len(); i++ {
			var q string
			q, err = r.MakeFilter(a.Index(i).Interface())
			if err != nil {
				return
			}
			c := strings.ReplaceAll(strings.ToUpper(q), " ", "")
			if (len(c) == 2 || len(c) == 3) && (c == "AND" || c == "OR") {
				connector = q
				continue
			}
			q = strings.Trim(q, " ")
			if q == "" {
				continue
			}
			if expr != "" && q != "" && len(q) >= 6 && q[:2] != "OR" && q[:3] != "AND" {
				err = fmt.Errorf(q + ` missing "connectBy":"OR|AND"`)
				z.Error(err.Error())
				return
			}
			expr = expr + " " + q
		}

		if connector != "" {
			expr = connector + " (" + expr + ")"
		} else {
			expr = " (" + expr + ")"
		}
	case reflect.Map:
		a := reflect.ValueOf(conditions).Interface()
		e, ok := a.(map[string]interface{})
		if !ok {
			errMsg := "invalid expression node"
			z.Error(errMsg)
			err = fmt.Errorf(errMsg)
			return
		}

		//{"email":{"ILIKE":"%@gzhu.edu.cn"},"connectBy":"AND"}
		for dbField, v := range e {
			//"connectBy":"AND"
			if strings.EqualFold(dbField, connectPreviousBy) {
				s, ok := v.(string)
				if !ok {
					err = fmt.Errorf("invalid expression connector")
					z.Error(err.Error())
					return
				}
				connector = strings.ToUpper(s)
				continue
			}

			k, jsonOpr := getColumnName(dbField)
			if k == "" {
				err = fmt.Errorf("invalid key: %s", dbField)
				z.Error(err.Error())
				return
			}

			dbColumnName, found := r.mapKey(k)
			if !found {
				err = fmt.Errorf("invalid key:" + k)
				z.Error(err.Error())
				return
			}

			if jsonOpr {
				dbColumnName = strings.ReplaceAll(dbField, k, dbColumnName)
			}

			//"email":{"ILIKE":"%@gzhu.edu.cn"}
			if reflect.ValueOf(v).Kind() != reflect.Map {
				err = fmt.Errorf("invalid expression value for key: " + k)
				z.Error(err.Error())
				return
			}

			x, ok := v.(map[string]interface{})
			if !ok {
				err = fmt.Errorf("invalid expression value for key: " + k)
				z.Error(err.Error())
				return
			}

			//"email":{"ILIKE": "%@gzhu.edu.cn"}
			//         operator  operand
			for operator, operand := range x {
				dstOpr, ok := mapOpr(operator)
				if !ok {
					err = fmt.Errorf("invalid opr: " + operator + " for key " + k)
					z.Error(err.Error())
					return
				}

				switch operator {
				case "EQ", "LT", "GT", "LTE", "GTE", "NEQ", "LIKE", "ILIKE":
					switch reflect.TypeOf(operand).Kind() {
					case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16,
						reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8,
						reflect.Uint16, reflect.Uint32, reflect.Float64,
						reflect.Uint64, reflect.Float32:

						filterValues := &r.Values
						beginPos := 0

						// 对于select/delete, r.values仅包含where中的参数值,expr中的参数从1开始
						// 对于update, r.values值还包含set column=value中的value值，因此
						//		expr中的参数从len(r.values) + 1开始
						if r.AuthProc {
							filterValues = &r.AuthWhereValues
							beginPos = r.AuthWhereBeginPos
						}

						expr = fmt.Sprintf("%s %s $%d", dbColumnName, dstOpr, beginPos+len(*filterValues)+1)
						*filterValues = append(*filterValues, operand)

						if v, ok := x["EXPR_IS"]; ok {
							var isOperand string
							isOperand, err = mapIsOperand(v)
							if err != nil {
								return
							}
							expr = fmt.Sprintf("(%s) IS %s", expr, isOperand)
							z.Info(expr)
						}
					case reflect.String:
						d, ok := operand.(string)
						if !ok || d == "" {
							err = fmt.Errorf("empty value for key " + k + " with operator " + operator)
							z.Error(err.Error())
							return
						}

						filterValues := &r.Values
						beginPos := 0
						if r.AuthProc {
							filterValues = &r.AuthWhereValues
							beginPos = r.AuthWhereBeginPos
						}

						expr = fmt.Sprintf("%s %s $%d", dbColumnName, dstOpr, beginPos+len(*filterValues)+1)
						*filterValues = append(*filterValues, operand)

						if v, ok := x["EXPR_IS"]; ok {
							var isOperand string
							isOperand, err = mapIsOperand(v)
							if err != nil {
								return
							}
							expr = fmt.Sprintf("(%s) IS %s", expr, isOperand)
							z.Info(expr)
						}
					default:
						err = fmt.Errorf("unsupported json data type: " + reflect.TypeOf(operand).Kind().String())
						z.Error(err.Error())
						return
					}

				case "IS":
					var isOperand string
					isOperand, err = mapIsOperand(operand)
					if err != nil {
						return
					}
					expr = fmt.Sprintf("%s %s %s", dbColumnName, operator, isOperand)

				case "RE":
					filterValues := &r.Values
					beginPos := 0
					if r.AuthProc {
						filterValues = &r.AuthWhereValues
						beginPos = r.AuthWhereBeginPos
					}

					expr = fmt.Sprintf("regexp_match(%s, $%d) IS NOT NULL", dbColumnName, beginPos+len(*filterValues)+1)
					*filterValues = append(*filterValues, operand)
					if v, ok := x["EXPR_IS"]; ok {
						var isOperand string
						isOperand, err = mapIsOperand(v)
						if err != nil {
							return
						}
						expr = fmt.Sprintf("(%s) IS %s", expr, isOperand)
						z.Info(expr)
					}

				case "IN", "BETWEEN", "NOT_BETWEEN",
					"BETWEEN_SYMMETRIC", "NOT_BETWEEN_SYMMETRIC":

					if reflect.TypeOf(operand).Kind() != reflect.Slice {
						err = fmt.Errorf("invalid " + operator + " opr value for key: " + k)
						z.Error(err.Error())
						return
					}
					var valueList string
					dv := reflect.ValueOf(operand)
					if dv.Len() == 0 {
						err = fmt.Errorf("empty value list for operator '" + operator + "' for key: " + k)
						z.Error(err.Error())
						return
					}

					filterValues := &r.Values
					beginPos := 0
					if r.AuthProc {
						filterValues = &r.AuthWhereValues
						beginPos = r.AuthWhereBeginPos
					}

					for j := 0; j < dv.Len(); j++ {
						dstValue := dv.Index(j).Interface()
						valueList = valueList + fmt.Sprintf("$%d,", beginPos+len(*filterValues)+1)
						*filterValues = append(*filterValues, dstValue)
					}

					if len(valueList) > 0 {
						valueList = valueList[:len(valueList)-1]
					}
					if operator == "IN" {
						expr = fmt.Sprintf("%s %s (%v)", dbColumnName, operator, valueList)
					} else {
						values := strings.Split(valueList, ",")
						if len(values) != 2 {
							err = fmt.Errorf("value's number should be TWO for key " + k + " with OPR: " + operator)
							z.Error(err.Error())
							return
						}
						expr = fmt.Sprintf("%s %s %v AND %v", dbColumnName, dstOpr, values[0], values[1])
					}

					if v, ok := x["EXPR_IS"]; ok {
						var isOperand string
						isOperand, err = mapIsOperand(v)
						if err != nil {
							return
						}
						expr = fmt.Sprintf("(%s) IS %s", expr, isOperand)
						z.Info(expr)
					}

				case "?|", "?&":
					var ok bool
					var values []interface{}

					if values, ok = operand.([]interface{}); !ok {
						err = fmt.Errorf("%s: %v value should be []interface{} with %s, while it's not",
							k, operand, operator)
						z.Error(err.Error())
						return
					}

					var stringValues []string
					for _, v := range values {
						var s string
						if s, ok = v.(string); !ok {
							err = fmt.Errorf("%s: %v value should be []interface{} with %s, while it's not",
								k, v, operator)
							z.Error(err.Error())
							return
						}
						stringValues = append(stringValues, s)
					}
					operand = stringValues
					fallthrough
				case "@>", "<@", "?", "@?", "@@":
					filterValues := &r.Values
					beginPos := 0
					if r.AuthProc {
						filterValues = &r.AuthWhereValues
						beginPos = r.AuthWhereBeginPos
					}

					expr = fmt.Sprintf("%s %s $%d", dbColumnName, dstOpr, beginPos+len(*filterValues)+1)
					*filterValues = append(*filterValues, operand)

					if v, ok := x["EXPR_IS"]; ok {
						var isOperand string
						isOperand, err = mapIsOperand(v)
						if err != nil {
							return
						}
						expr = fmt.Sprintf("(%s) IS %s", expr, isOperand)
						z.Info(expr)
					}

				case "vars", "silent", "EXPR_IS":
					continue

				case "jsonb_path_exists", "jsonb_path_exists_tz",
					"jsonb_path_match", "jsonb_path_match_tz":
					filterValues := &r.Values
					beginPos := 0
					if r.AuthProc {
						filterValues = &r.AuthWhereValues
						beginPos = r.AuthWhereBeginPos
					}

					expr = fmt.Sprintf("%s(%s,$%d", dstOpr, dbColumnName, beginPos+len(*filterValues)+1)
					*filterValues = append(*filterValues, operand)

					if v, ok := x["vars"]; ok {
						expr = fmt.Sprintf("%s,$%d", expr, beginPos+len(*filterValues)+1)
						*filterValues = append(*filterValues, v)
					}

					if v, ok := x["silent"]; ok {
						expr = fmt.Sprintf("%s,$%d", expr, beginPos+len(*filterValues)+1)
						*filterValues = append(*filterValues, v)
					}
					expr = expr + ")"

					if v, ok := x["EXPR_IS"]; ok {
						var isOperand string
						isOperand, err = mapIsOperand(v)
						if err != nil {
							return
						}
						expr = fmt.Sprintf("(%s) IS %s", expr, isOperand)
						z.Info(expr)
					}
				default:
					err = fmt.Errorf("unsupported opr: " + operator)
					z.Error(err.Error())
					return
				}
			}
		}

		if connector != "" {
			expr = connector + " " + expr
		}
	case reflect.Struct:
		err = fmt.Errorf("invalid filter expression: " +
			objType.Name() + ", it should be slice or map")
		z.Error(err.Error())
		return

	default:
		err = fmt.Errorf("invalid filter expression: " +
			objType.Kind().String() + ", it should be slice or map")
		z.Error(err.Error())
		return
	}
	return
}

func (r *Filter) getPrimaryKeys(includeAllKey bool) (primaryKeys []string, err error) {
	p := reflect.ValueOf(r.TableMap)
	if p.IsNil() {
		z.Error("tableDefineStructPtr is nil")
		return
	}

	t := reflect.TypeOf(p.Elem().Interface())

	if t.Kind() != reflect.Struct {
		z.Error(t.Name() + " is not struct")
		return
	}

	var existsColumnNameID bool
	var columnIDName string
	for i := 0; i < t.NumField(); i++ {
		s, ok := t.Field(i).Tag.Lookup("db")
		if !ok || s == "" {
			continue
		}
		attr := strings.Split(s, ",")
		if len(attr) < 2 {
			continue
		}

		if strings.ToUpper(attr[0]) == "ID" {
			columnIDName = attr[0]
			existsColumnNameID = true
		}
		n := strings.ToUpper(attr[1])
		if n == "FALSE" {
			continue
		}
		primaryKeys = append(primaryKeys, attr[0])
		if !includeAllKey {
			break
		}
	}

	if len(primaryKeys) == 0 && existsColumnNameID {
		primaryKeys = append(primaryKeys, columnIDName)
	}

	return
}

// mapIsOperand map IS operand from symbol to pg IS operand
func mapIsOperand(operand interface{}) (isOperand string, err error) {
	var ok bool
	isOperand, ok = operand.(string)
	if !ok {
		err = fmt.Errorf(`unsupported opr "IS"'s operand value type,` +
			`please use json string just like {"DevID": {"IS": "NULL"}}`)
		z.Error(err.Error())
		return
	}

	isOperand = strings.ToUpper(strings.Trim(isOperand, " "))
	_, ok = isOperandList[isOperand]
	if !ok {
		err = fmt.Errorf(`unsupported opr "IS"'s operand value ` +
			isOperand + `, please use json string just like {"DevID": {"IS": "NULL"}}`)
		z.Error(err.Error())
		return
	}

	return
}
